#include <Wire.h>
#include "MAX30105.h"
#include "heartRate.h" 
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <WiFi.h>
#include <time.h>
#include <sntp.h> 
#include <Arduino.h> 

/* ===== WIFI & NTP CONFIGURATION ===== */
// VUI LÒNG ĐIỀN THÔNG TIN MẠNG CỦA BẠN
const char* ssid     = "MU VO DICH";
const char* password = "12344321";

// Cấu hình thời gian
const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 7 * 3600; 
const int   daylightOffset_sec = 0;

/* ===== OLED SETTINGS ===== */
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

/* ===== ESP32-C3 PINS & CONFIG ===== */
#define I2C_SDA 8
#define I2C_SCL 9
#define BTN_PIN 4      
#define STATUS_LED_PIN 5 

/* ===== MAX30102 SENSOR & BUFFERS ===== */
MAX30105 sensor;

#define IR_THRESHOLD 40000 
#define RR_BUF 6       
float rrBuf[RR_BUF];
uint8_t rrCount = 0;
uint8_t rrIndex = 0;

#define BUF_SIZE 200 // Tăng từ 100 lên 200 mẫu để cải thiện độ chính xác SpO2
uint32_t irBuffer[BUF_SIZE];
uint32_t redBuffer[BUF_SIZE];
uint8_t bufferIndex = 0;

/* ===== STATUS & TIME VARIABLES ===== */
float bpmStable = 0;
bool bpmReady = false;
float spo2Stable = 0.0;
uint8_t currentHour = 0;
uint8_t currentMinute = 0;
bool measuring = false; 

unsigned long lastBeat = 0;
unsigned long lastOLED = 0;
unsigned long lastBtn = 0;

/* ================================================= */
/* ===== KHAI BÁO NGUYÊN MẪU HÀM (PROTOTYPES) ===== */
/* ================================================= */

void drawBattery(uint8_t x, uint8_t y, uint8_t level);
void drawWifi(uint8_t x, uint8_t y);
void drawHeart(uint8_t x, uint8_t y);
void drawO2Icon(uint8_t x, uint8_t y);

void resetAll();
void startMeasuring();
void setupNTP();

void showStatus(uint8_t bpm, long irValue); 

float calculateSpO2(uint32_t *ir, uint32_t *red, uint8_t size);
void printLocalTime(uint8_t &hour, uint8_t &minute);

/* ================================================= */
/* ===== HÀM CƠ BẢN VÀ QUẢN LÝ TRẠNG THÁI ===== */
/* ================================================= */

void resetAll() {
  rrCount = 0;
  rrIndex = 0;
  bpmReady = false;
  bpmStable = 0;
  spo2Stable = 0.0;
  bufferIndex = 0;
  lastBeat = 0;
  sensor.setPulseAmplitudeRed(0x00); 
  digitalWrite(STATUS_LED_PIN, LOW);
  measuring = false; 
}

void startMeasuring() {
  resetAll(); 
  measuring = true; 
  digitalWrite(STATUS_LED_PIN, HIGH); 
  Serial.println("--- START MEASURING ---");
  showStatus((int)bpmStable, 0); 
}

void setupNTP() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.println("Connecting to WiFi...");
  display.display();
  
  WiFi.begin(ssid, password);

  int attempt = 0;
  while (WiFi.status() != WL_CONNECTED && attempt < 20) {
    delay(500);
    display.print(".");
    display.display();
    attempt++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  }
}

/* ================================================= */
/* ===== HÀM HỖ TRỢ VẼ ICON CHO OLED ===== */
/* ================================================= */

void drawBattery(uint8_t x, uint8_t y, uint8_t level) {
  display.drawRect(x, y + 2, 14, 8, SSD1306_WHITE);
  display.drawRect(x + 14, y + 4, 2, 4, SSD1306_WHITE);
  uint8_t barWidth = 12 * (level / 100.0);
  display.fillRect(x + 1, y + 3, barWidth, 6, SSD1306_WHITE);
}

void drawWifi(uint8_t x, uint8_t y) {
  display.drawPixel(x + 4, y + 8, SSD1306_WHITE);
  display.drawFastHLine(x + 3, y + 6, 3, SSD1306_WHITE);
  display.drawFastHLine(x + 1, y + 4, 7, SSD1306_WHITE);
}

void drawHeart(uint8_t x, uint8_t y) {
  display.fillRect(x + 1, y, 2, 2, SSD1306_WHITE);
  display.fillRect(x + 5, y, 2, 2, SSD1306_WHITE);
  display.fillRect(x, y + 2, 8, 2, SSD1306_WHITE);
  display.fillRect(x + 1, y + 4, 6, 2, SSD1306_WHITE);
  display.fillRect(x + 2, y + 6, 4, 2, SSD1306_WHITE);
  display.fillRect(x + 3, y + 8, 2, 2, SSD1306_WHITE);
}

void drawO2Icon(uint8_t x, uint8_t y) {
  display.setTextSize(1); 
  display.setCursor(x, y);
  display.print("O");
  display.setTextSize(1);
  display.setCursor(x + 8, y + 4); 
  display.print("2");
}

/* ================================================= */
/* ===== HÀM TÍNH TOÁN SPO2 VÀ THỜI GIAN THỰC ===== */
/* ================================================= */

void printLocalTime(uint8_t &hour, uint8_t &minute) {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return; 
  }
  hour = timeinfo.tm_hour;
  minute = timeinfo.tm_min;
}

float calculateSpO2(uint32_t *ir, uint32_t *red, uint8_t size) {
    if (size < 10) return 0.0; 
    
    uint32_t irMin = 0xFFFFFFFF, irMax = 0;
    uint32_t redMin = 0xFFFFFFFF, redMax = 0;

    for (int i = 0; i < size; i++) { 
        if (ir[i] > irMax) irMax = ir[i];
        if (ir[i] < irMin) irMin = ir[i];
        if (red[i] > redMax) redMax = red[i];
        if (red[i] < redMin) redMin = red[i];
    }
    
    if (irMin == irMax || redMin == redMax) return 0.0;

    float irAC = (float)(irMax - irMin);
    float redAC = (float)(redMax - redMin);
    float irDC = (float)(irMin + irMax) / 2.0;
    float redDC = (float)(redMin + redMax) / 2.0;

    if (irDC == 0.0 || redDC == 0.0) return 0.0;
    
    float R = (redAC / redDC) / (irAC / irDC);

    float SpO2 = 110.0 - 25.0 * R; 
    
    if (SpO2 > 100.0) return 100.0;
    if (SpO2 < 85.0) return 85.0;

    return SpO2;
}

/* ================================================= */
/* ===== HÀM HIỂN THỊ THỐNG NHẤT (ĐÃ TỐI ƯU ĐỒNG NHẤT) ===== */
/* ================================================= */

void showStatus(uint8_t bpm, long irValue) { 
  display.clearDisplay();
  
  printLocalTime(currentHour, currentMinute);
  
  // --- Hàng trên cùng (Icon Wi-Fi & Pin) ---
  if (WiFi.status() == WL_CONNECTED) drawWifi(5, 0); 
  drawBattery(SCREEN_WIDTH - 20, 0, 75); 
  
  // --- Thời gian thực (Căn giữa) ---
  display.setTextSize(2);
  display.setCursor(40, 10); 
  display.printf("%02d:%02d", currentHour, currentMinute);
  
  // XÁC ĐỊNH ĐIỀU KIỆN HIỂN THỊ ĐỒNG NHẤT:
  // Hiển thị chỉ khi ĐANG ĐO + CÓ NGÓN TAY + ĐỦ SỐ MẪU TỐI THIỂU CHO SPO2 (10 mẫu)
  bool spO2_min_samples_ready = (bufferIndex >= 10);
  bool showData_synced = measuring && (irValue >= IR_THRESHOLD) && spO2_min_samples_ready; 
  
  // --- Hàng 3: Nhịp Tim (BPM) ---
  drawHeart(10, 34); 
  display.setTextSize(2);
  display.setCursor(30, 30); 
  
  if (showData_synced) {
    // Ưu tiên hiển thị BPM ổn định, nếu không, hiển thị BPM thô
    if (bpmReady || bpmStable > 0) { 
        display.print(bpm);
    } else if (rrCount > 0) {
        float rrAvg = 0;
        for (int i = 0; i < rrCount; i++) rrAvg += rrBuf[i];
        rrAvg /= rrCount;
        float rawBPM = 60.0 / rrAvg;
        display.print((int)rawBPM);
    } else {
        display.print("----");
    }
  } else {
    display.print("----"); // ẨN cho đến khi SpO2 thô sẵn sàng
  }
  
  display.setTextSize(1);
  display.setCursor(80, 35);
  display.print("BPM");
  
  // --- Hàng 4: Nồng độ Oxi (SpO2) ---
  drawO2Icon(10, 50); 
  display.setTextSize(2);
  display.setCursor(30, 50);
  
  if (showData_synced) {
    if (spo2Stable > 85.0) {
        display.print((int)spo2Stable);
    } else if (spO2_min_samples_ready) { 
        // Hiển thị SpO2 thô
        float rawSpO2 = calculateSpO2(irBuffer, redBuffer, bufferIndex);
        if (rawSpO2 > 85.0) {
            display.print((int)rawSpO2);
        } else {
            display.print("----");
        }
    } else {
        display.print("----");
    }

  } else {
    display.print("----"); // ẨN cho đến khi SpO2 thô sẵn sàng
  }

  display.setTextSize(1);
  display.setCursor(80, 55);
  display.print("%");

  display.display();
}

/* ================================================= */

void setup() {
  Serial.begin(115200);
  Wire.begin(I2C_SDA, I2C_SCL);

  pinMode(BTN_PIN, INPUT_PULLUP);
  pinMode(STATUS_LED_PIN, OUTPUT); 
  digitalWrite(STATUS_LED_PIN, LOW); 

  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.setTextColor(SSD1306_WHITE);
  display.clearDisplay();

  setupNTP();

  if (!sensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("MAX30105 not found. Check wiring!");
    while (1);
  }

  // Tăng ADC Range lên 8192 để cải thiện độ chính xác SpO2 (tùy chọn)
  // sensor.setup(0x1F, 4, 2, 400, 411, 8192); 
  sensor.setup(0x1F, 4, 2, 400, 411, 4096); 
  sensor.setPulseAmplitudeIR(0x2A);
  sensor.setPulseAmplitudeRed(0x00); 

  showStatus(0, 0); 
}

void loop() {
  long irValue = sensor.getIR();
  long redValue = sensor.getRed(); 

  /* ===== BUTTON (TOGGLE MEASURE) ===== */
  if (digitalRead(BTN_PIN) == LOW && millis() - lastBtn > 400) {
    lastBtn = millis();

    if (!measuring) {
      startMeasuring(); 
    } else {
      resetAll(); 
    }
    // Cập nhật màn hình ngay sau khi nhấn nút
    showStatus((int)bpmStable, irValue); 
  }

  /* ===== DATA COLLECTION & PROCESSING ===== */
  if (measuring) {
    
    // Nếu không có ngón tay (IR thấp)
    if (irValue < IR_THRESHOLD) {
      sensor.setPulseAmplitudeRed(0x00); 
      bufferIndex = 0; 
      bpmReady = false; 
    } else {
      sensor.setPulseAmplitudeRed(0x0A); // Bật LED Đỏ khi có ngón tay
      
      // -- Thu thập dữ liệu SpO2 --
      if (bufferIndex < BUF_SIZE) {
        irBuffer[bufferIndex] = irValue;
        redBuffer[bufferIndex] = redValue;
        bufferIndex++;
      } else {
        // Tính toán SpO2 thô
        float newSpO2 = calculateSpO2(irBuffer, redBuffer, BUF_SIZE);
        // LỌC LÀM MỊN SPO2: Tăng cường độ làm mịn (0.3/0.7)
        if (bpmReady) {
          spo2Stable = (spo2Stable == 0.0) ? newSpO2 : (0.3 * newSpO2 + 0.7 * spo2Stable);
        }
        bufferIndex = 0; 
      }

      // -- Xử lý BPM --
      if (checkForBeat(irValue)) {
        unsigned long now = millis();
        float rr = (now - lastBeat) / 1000.0;
        lastBeat = now;

        if (rr > 0.33 && rr < 1.5) { 
          rrBuf[rrIndex] = rr;
          rrIndex = (rrIndex + 1) % RR_BUF;
          if (rrCount < RR_BUF) rrCount++;

          if (rrCount >= RR_BUF) {
            float rrAvg = 0;
            for (int i = 0; i < RR_BUF; i++) rrAvg += rrBuf[i];
            rrAvg /= RR_BUF;

            float newBPM = 60.0 / rrAvg;

            // LỌC LÀM MỊN BPM: Tăng cường độ làm mịn (0.2/0.8)
            bpmStable = bpmReady ?
                          (0.2 * newBPM + 0.8 * bpmStable) : 
                          newBPM;

            bpmReady = true;
          }
        }
      }
    }
  }

  /* ===== OLED UPDATE (Luôn hiển thị màn hình Status) ===== */
  if (millis() - lastOLED > 500) {
    lastOLED = millis();
    showStatus((int)bpmStable, irValue); 
  }
}
